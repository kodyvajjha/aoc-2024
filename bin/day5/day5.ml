[@@@warning "-32-33"]

let test =
  {|47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47|}

let test2 = {|75,47,61,53,29
97,61,53,29,13
75,29,13
|}

module Solving = struct
  type t = {
    rules: (int * int) list;
    updates: int list list;
  }

  let pp fpf t =
    let module D = CCFormat.Dump in
    CCFormat.fprintf fpf "%a"
      D.(pair D.(list (pair int int)) D.(list (list int)))
      (t.rules, t.updates)

  (* Check if ordered pairs generated by an update list all exist in the rules. This can be done recursively on each update, seems like. *)

  module Part1 = struct
    let all_pairs l =
      let rec pairs (l : int list) =
        match l with
        | y :: ys -> [ CCList.map (fun x -> y, x) ys ] @ pairs ys
        | _ -> []
      in
      pairs l |> CCList.flatten

    let in_right_order t (l : int list) =
      let rec check (l : (int * int) list) =
        match l with
        | (x, y) :: xys ->
          if CCList.exists (fun ab -> ab = (x, y)) t.rules then
            check xys
          else
            false
        | [] -> true
      in
      check (all_pairs l)

    let solve t =
      let res =
        let open CCList in
        let+ l = filter (fun x -> in_right_order t x) t.updates in
        get_at_idx_exn (length l / 2) l
      in
      CCList.fold_left ( + ) 0 res
  end

  module Part2 = struct end
end

module Parsing = struct
  open CCParse

  let rule =
    let* n1 = U.int <* skip_space in
    let* _ = char '|' <* skip_space in
    let* n2 = U.int in
    pure (n1, n2)

  let rules = many rule

  let update = sep ~by:(char ',') U.int

  let updates = sep ~by:endline update

  let input =
    let open Solving in
    let* rules = rules in
    let* _ = endline in
    let* updates = updates in
    pure { rules; updates = CCList.filter (fun x -> x != CCList.empty) updates }
end

let () =
  let res =
    let open CCResult in
    let* t = CCParse.parse_string Parsing.input test in
    pure @@ Solving.Part1.(solve t)
  in
  CCFormat.printf "@.Part1 : %a" (CCResult.pp CCFormat.(int)) res

let () =
  let res =
    let open CCResult in
    let* t = CCParse.parse_file Parsing.input "bin/day5/input.txt" in
    pure @@ Solving.Part1.(solve t)
  in
  CCFormat.printf "@.Part1 : %a" (CCResult.pp CCFormat.(int)) res

(* let () =
   let l = [ 75; 47; 61; 53; 29 ] in
   let res =
     let open CCResult in
     let* t = CCParse.parse_string Parsing.input test in
     pure @@ Solving.Part1.(solve t)
   in
   CCFormat.printf "@.%a @.all_pairs: %a@.in_right_order: %a"
     CCFormat.Dump.(list int)
     l
     CCFormat.Dump.(list (pair int int))
     (Solving.Part1.all_pairs l)
     (CCResult.pp CCFormat.(int))
     res *)
