[@@@warning "-32-33"]

let test =
  {|47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47|}

let test2 = {|75,47,61,53,29
97,61,53,29,13
75,29,13
|}

module Solving = struct
  type t = {
    rules: (int * int) list;
    updates: int list list;
  }

  let pp fpf t =
    let module D = CCFormat.Dump in
    CCFormat.fprintf fpf "%a"
      D.(pair D.(list (pair int int)) D.(list (list int)))
      (t.rules, t.updates)

  (* Check if ordered pairs generated by an update list all exist in the rules. This can be done recursively on each update, seems like. *)

  module Part1 = struct
    let all_pairs l =
      let rec pairs (l : int list) =
        match l with
        | y :: ys -> [ CCList.map (fun x -> y, x) ys ] @ pairs ys
        | _ -> []
      in
      pairs l |> CCList.flatten

    let in_right_order t (l : int list) =
      let rec check (l : (int * int) list) =
        match l with
        | (x, y) :: xys ->
          if CCList.exists (fun ab -> ab = (x, y)) t.rules then
            check xys
          else
            false
        | [] -> true
      in
      check (all_pairs l)

    let solve t =
      let res =
        let open CCList in
        let+ l = filter (fun x -> in_right_order t x) t.updates in
        get_at_idx_exn (length l / 2) l
      in
      CCList.fold_left ( + ) 0 res
  end

  module Part2 = struct
    let get_id x l =
      CCArray.find_idx (( = ) x) l
      |> CCOption.get_exn_or (CCFormat.sprintf "no such element %d" x)
      |> fst

    (** Rearranges a badly arranged list. *)
    let rearrange t (l : int list) : int list =
      assert (not (Part1.in_right_order t l));
      let all_pairs = Part1.all_pairs l in
      (* CCFormat.printf "@.all_pairs: %a"
           CCFormat.Dump.(list (pair int int))
           all_pairs;
         CCFormat.printf "@.rules: %a" CCFormat.Dump.(list (pair int int)) t.rules; *)
      let arr = CCArray.of_list l in
      let rearrange_single arr (x, y) =
        if CCList.exists (fun ab -> ab = (x, y)) t.rules then
          ()
        else (
          let idx = get_id x arr in
          let idy = get_id y arr in

          CCFormat.printf "@.rearranging %a! (idx,idy) : %a"
            CCFormat.Dump.(pair int int)
            (x, y)
            CCFormat.Dump.(pair int int)
            (idx, idy);
          CCFormat.printf "@.Before: %a" CCFormat.Dump.(array int) arr;
          arr.(idx) <- y;
          arr.(idy) <- x;
          CCFormat.printf "@.After: %a" CCFormat.Dump.(array int) arr
        )
      in
      CCList.iter (rearrange_single arr) all_pairs;
      CCFormat.printf "@.%a" CCFormat.Dump.(list int) (arr |> CCArray.to_list);
      assert (Part1.in_right_order t (arr |> CCArray.to_list));
      arr |> CCArray.to_list

    let solve t =
      let mid_corrects =
        let open CCList in
        let+ corrects =
          (* List of all updates in the wrong order. *)
          let res =
            filter (fun x -> not (Part1.in_right_order t x)) t.updates
          in
          let+ update = res in
          rearrange t update
        in
        get_at_idx_exn (length corrects / 2) corrects
      in
      CCList.fold_left ( + ) 0 mid_corrects
  end
end

module Parsing = struct
  open CCParse

  let rule =
    let* n1 = U.int <* skip_space in
    let* _ = char '|' <* skip_space in
    let* n2 = U.int in
    pure (n1, n2)

  let rules = many rule

  let update = sep ~by:(char ',') U.int

  let updates = sep ~by:endline update

  let input =
    let open Solving in
    let* rules = rules in
    let* _ = endline in
    let* updates = updates in
    pure { rules; updates = CCList.filter (fun x -> x != CCList.empty) updates }
end

let () =
  let res =
    let open CCResult in
    let* t = CCParse.parse_string Parsing.input test in
    pure @@ Solving.Part1.(solve t)
  in
  CCFormat.printf "@.Part1 : %a" (CCResult.pp CCFormat.(int)) res

let () =
  let res =
    let open CCResult in
    let* t = CCParse.parse_file Parsing.input "bin/day5/input.txt" in
    pure @@ Solving.Part1.(solve t)
  in
  CCFormat.printf "@.Part1 : %a" (CCResult.pp CCFormat.(int)) res

let () =
  let res =
    let open CCResult in
    let+ t = CCParse.parse_string Parsing.input test in
    Solving.Part2.solve t
    (* Solving.Part2.rearrange t [ 97; 13; 75; 29; 47 ] *)
  in
  CCFormat.printf "@.Part2 : %a" (CCResult.pp CCFormat.Dump.(int)) res

let () =
  let res =
    let open CCResult in
    let+ t = CCParse.parse_file Parsing.input "bin/day5/input.txt" in
    Solving.Part2.solve t
  in

  CCFormat.printf "@.Part2 : %a" (CCResult.pp CCFormat.Dump.(int)) res
